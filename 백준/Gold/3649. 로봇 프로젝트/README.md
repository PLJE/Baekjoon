# [Gold V] 로봇 프로젝트 - 3649 

[문제 링크](https://www.acmicpc.net/problem/3649) 

### 성능 요약

메모리: 10224 KB, 시간: 3852 ms

### 분류

이분 탐색(binary_search), 정렬(sorting), 두 포인터(two_pointer)

### 문제 설명

<p>상근이와 선영이는 학교 숙제로 로봇을 만들고 있다. 로봇을 만들던 중에 구멍을 막을 두 레고 조각이 필요하다는 것을 깨달았다.</p>

<p>구멍의 너비는 x 센티미터이고, 구멍에 넣을 두 조각의 길이의 합은 구멍의 너비와 정확하게 일치해야 한다. 정확하게 일치하지 않으면, 프로젝트 시연을 할 때 로봇은 부수어질 것이고 상근이와 선영이는 F를 받게 된다. 구멍은 항상 두 조각으로 막아야 한다.</p>

<p>지난밤, 상근이와 선영이는 물리 실험실에 들어가서 레고 조각의 크기를 모두 정확하게 재고 돌아왔다. 구멍을 완벽하게 막을 수 있는 두 조각을 구하는 프로그램을 작성하시오.</p>

### 입력 

 <p>입력은 여러 개의 테스트 케이스로 이루어져 있다.</p>

<p>각 테스트 케이스의 첫째 줄에는 구멍의 너비 x (1 ≤ x ≤ 20, x는 정수)가 주어진다. x의 단위는 센티미터이다.</p>

<p>다음 줄에는 물리 실험실에 있는 레고 조각의 수 n이 주어진다. (0 ≤ n ≤ 1000000)</p>

<p>다음 n개의 줄에는 레고 조각의 길이 ℓ이 주어진다. ℓ은 양의 정수이며, 단위는 나노미터이다. 블록의 길이는 10 센티미터 (100000000 나노미터)를 넘지 않는다.</p>

### 출력 

 <p>각 테스트 케이스마다 한 줄에 하나씩, 구멍을 완벽하게 막을 수 있는 두 조각이 없다면 'danger'를 출력한다. 막을 수 있는 경우에는 'yes ℓ<sub>1</sub> ℓ<sub>2</sub>'를 출력한다. (ℓ<sub>1</sub> ≤ ℓ<sub>2</sub>)</p>

<p>정답이 여러 개인 경우에는 |ℓ<sub>1</sub> - ℓ<sub>2</sub>|가 가장 큰 것을 출력한다.</p>

### 내 풀이
- 이분탐색 분류에서 찾아 풀었지만, 이 문제의 경우 n의 범위가 그렇게 크지 않기 때문에, 투 포인터로도 해결이 가능했다.
- 반드시 두 블록으로 막아야 한다 -> 개수가 2로 정해져 있다는 것에서 투 포인터 접근 방법을 쉽게 떠올릴 수 있다.
- 정렬은 기본!
- 문제와 구현 자체는 어렵지 않으나 이 문제가 악랄한 이유는 '여러 개의 인풋을 받는다' 때문이다. 
- 따로 case의 개수를 입력 받지는 않기 때문에 while문을 돌면서 여러 케이스를 받고, EOF일 경우 종료하도록 작성해야 한다. (이거 때문에 계속 틀렸다.)
